/*
 * Copyright (C) 2025 wolfSSL Inc.
 *
 * This file is part of wolfHSM.
 *
 * wolfHSM is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * wolfHSM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with wolfHSM.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "wolfhsm/wh_settings.h"


#include <stdint.h>
#include <stdio.h> /* For WH_ERROR_PRINT */
#include <string.h> /* For memset, memcpy */

#include "wolfssl/wolfcrypt/settings.h"
#include "wolfssl/wolfcrypt/types.h"

#include "wolfhsm/wh_error.h"
#include "wolfhsm/wh_flash.h"

#ifdef WOLFHSM_CFG_KEYWRAP

#ifdef WOLFHSM_CFG_ENABLE_CLIENT
#include "wolfhsm/wh_client.h"
#include "wolfhsm/wh_client_crypto.h"
#endif

#include "wolfhsm/wh_comm.h"
#include "wolfhsm/wh_message.h"
#include "wolfhsm/wh_transport_mem.h"
#include "wolfhsm/wh_nvm.h"

#include "wh_test_common.h"

#ifdef WOLFHSM_CFG_ENABLE_CLIENT

/* Common defines */
#define WH_TEST_KEKID 1

/* AES GCM Specific defines */
#ifdef HAVE_AESGCM

#define WH_TEST_AESGCM_KEY_OFFSET 0x1000
#define WH_TEST_AESGCM_KEYID 2
#define WH_TEST_AES_KEYSIZE 32
#define WH_TEST_AES_TEXTSIZE 16
#define WH_TEST_AES_IVSIZE 12
#define WH_TEST_AES_TAGSIZE 16
#define WH_TEST_AES_WRAPPED_KEYSIZE                                   \
    (WH_TEST_AES_IVSIZE + WH_TEST_AES_TAGSIZE + WH_TEST_AES_KEYSIZE + \
     sizeof(whNvmMetadata))

#endif /* HAVE_AESGCM */

/* RSA Specific defines */
#ifndef NO_RSA

#define WH_TEST_RSA_KEY_OFFSET 0x2000
#define WH_TEST_RSA_KEYID 3
#define WH_TEST_RSA_KEYSIZE 1766
#define WH_TEST_RSA_WRAPPED_KEYSIZE                                   \
    (WH_TEST_AES_IVSIZE + WH_TEST_AES_TAGSIZE + WH_TEST_RSA_KEYSIZE + \
     sizeof(whNvmMetadata))
#endif /* !NO_RSA */

static int _InitServerKek(whClientContext* ctx)
{
    whKeyId serverKeyId             = WH_TEST_KEKID;
    uint8_t label[WH_NVM_LABEL_LEN] = "Server KEK key";
    uint8_t kek[] = {0x03, 0x03, 0x0d, 0xd9, 0xeb, 0x18, 0x17, 0x2e,
                     0x06, 0x6e, 0x19, 0xce, 0x98, 0x44, 0x54, 0x0d,
                     0x78, 0xa0, 0xbe, 0xe7, 0x35, 0x43, 0x40, 0xa4,
                     0x22, 0x8a, 0xd1, 0x0e, 0xa3, 0x63, 0x1c, 0x0b};

    return wh_Client_KeyCache(ctx, 0, label, sizeof(label), kek, sizeof(kek),
                              &serverKeyId);
}

static int _CleanupServerKek(whClientContext* ctx)
{
    return wh_Client_KeyErase(ctx, WH_TEST_KEKID);
}

#ifdef HAVE_AESGCM

static int _AesGcm_KeyWrap(whClientContext* ctx, WC_RNG* rng)
{

    int           ret = 0;
    uint8_t       iv[WH_TEST_AES_IVSIZE];
    uint8_t       plainKey[WH_TEST_AES_KEYSIZE];
    uint8_t       tmpPlainKey[WH_TEST_AES_KEYSIZE];
    uint8_t       wrappedKey[WH_TEST_AES_WRAPPED_KEYSIZE];
    whKeyId       wrappedKeyId;
    whNvmMetadata metadata = {
        .id = 8, .label = "AES Key Label", .len = WH_TEST_AES_KEYSIZE};
    whNvmMetadata tmpMetadata;

    ret = wc_RNG_GenerateBlock(rng, plainKey, sizeof(plainKey));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_RNG_GenerateBlock for key data %d\n", ret);
        return ret;
    }

    ret = wc_RNG_GenerateBlock(rng, iv, sizeof(iv));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_RNG_GenerateBlock for IV %d\n", ret);
        return ret;
    }

    ret = wh_Client_KeyWrap(ctx, WC_CIPHER_AES_GCM, WH_TEST_KEKID, plainKey,
                            sizeof(plainKey), &metadata, wrappedKey,
                            sizeof(wrappedKey));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_AesGcmKeyWrap %d\n", ret);
        return ret;
    }

    ret = wh_Client_KeyUnwrapAndCache(ctx, WC_CIPHER_AES_GCM, WH_TEST_KEKID,
                                      wrappedKey, sizeof(wrappedKey),
                                      &wrappedKeyId);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_AesGcmKeyWrapCache %d\n", ret);
        return ret;
    }

    ret = wh_Client_KeyUnwrapAndExport(
        ctx, WC_CIPHER_AES_GCM, WH_TEST_KEKID, wrappedKey, sizeof(wrappedKey),
        &tmpMetadata, tmpPlainKey, sizeof(tmpPlainKey));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_AesGcmKeyUnwrapAndCache %d\n", ret);
        return ret;
    }

    if (memcmp(plainKey, tmpPlainKey, sizeof(plainKey)) != 0) {
        WH_ERROR_PRINT("AES GCM wrap/unwrap key failed to match\n");
        return ret;
    }

    if (memcmp(&metadata, &tmpMetadata, sizeof(metadata)) != 0) {
        WH_ERROR_PRINT("AES GCM wrap/unwrap metadata failed to match\n");
        return ret;
    }

    return ret;
}

#endif /* HAVE_AESGCM */

int whTest_Client_KeyWrap(whClientContext* ctx)
{
    int    ret = 0;
    WC_RNG rng[1];

    _InitServerKek(ctx);

    ret = wc_InitRng_ex(rng, NULL, WH_DEV_ID);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_InitRng_ex %d\n", ret);
        return ret;
    }

#ifdef HAVE_AESGCM
    ret = _AesGcm_KeyWrap(ctx, rng);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to wc_InitRng_ex %d\n", ret);
    }
#endif

    _CleanupServerKek(ctx);

    (void)wc_FreeRng(rng);
    return ret;
}

int whTest_KeyWrapClientConfig(whClientConfig* clientCfg)
{
    int             ret       = 0;
    whClientContext client[1] = {0};

    if (clientCfg == NULL) {
        return WH_ERROR_BADARGS;
    }

    WH_TEST_RETURN_ON_FAIL(wh_Client_Init(client, clientCfg));

    ret = wh_Client_CommInit(client, NULL, NULL);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_Init %d\n", ret);
        goto cleanup_and_exit;
    }

    ret = whTest_Client_KeyWrap(client);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to whTest_Client_KeyWrap %d\n", ret);
    }

    /* Clean up used resources */
cleanup_and_exit:
    (void)wh_Client_CommClose(client);
    (void)wh_Client_Cleanup(client);

    return ret;
}

#ifdef HAVE_AESGCM
static int _AesGcm_WriteWrappedKeyToNvm(whClientContext* client, void* flashCtx,
                                        whFlashCb* flashCb)
{
    int     ret;
    whKeyId serverKekId = WH_TEST_KEKID;

    uint8_t aesGcmKey[WH_TEST_AES_KEYSIZE] = {
        0x7d, 0x7b, 0xa6, 0xf9, 0x1b, 0x34, 0x78, 0xbd, 0x5f, 0x2e, 0xf0,
        0xd6, 0xc4, 0xd9, 0x74, 0x3b, 0x4b, 0x38, 0x2b, 0x49, 0x54, 0x40,
        0x64, 0x7e, 0x60, 0x19, 0x7c, 0x82, 0xb8, 0x18, 0xfe, 0x7a};
    uint8_t aesGcmWrappedKey[WH_TEST_AES_WRAPPED_KEYSIZE];

    /* This is metadata tied to the AES GCM key for the server to use */
    whNvmMetadata aesGcmKeyMetadata = {
        .label  = "AES GCM Key",
        .access = WH_NVM_ACCESS_ANY,
        .flags  = WH_NVM_FLAGS_NONE,
        .id     = WH_MAKE_KEYID(WH_KEYTYPE_CRYPTO, 0, WH_TEST_AESGCM_KEYID),
        .len    = WH_TEST_AES_KEYSIZE};

    /* Request the server to wrap the AES GCM key using the server KEK */
    ret = wh_Client_KeyWrap(client, WC_CIPHER_AES_GCM, serverKekId, aesGcmKey,
                            sizeof(aesGcmKey), &aesGcmKeyMetadata,
                            aesGcmWrappedKey, sizeof(aesGcmWrappedKey));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_KeyWrap %d\n", ret);
        return ret;
    }

    /* Write the wrapped AES GCM key to a specified location in NVM */
    ret = flashCb->Program(flashCtx, WH_TEST_AESGCM_KEY_OFFSET,
                           sizeof(aesGcmWrappedKey), aesGcmWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to write AES GCM key to NVM %d\n", ret);
        return ret;
    }

    ret = flashCb->Verify(flashCtx, WH_TEST_AESGCM_KEY_OFFSET,
                          sizeof(aesGcmWrappedKey), aesGcmWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to verify the AES GCM key written to flash %d\n",
                       ret);
        return ret;
    }

    return ret;
}

static int _AesGcm_UseWrappedKeyFromNvm(whClientContext* client, void* flashCtx,
                                        whFlashCb* flashCb)
{
    int     ret;
    whKeyId serverKekId = WH_TEST_KEKID;

    Aes           aes[1];
    whKeyId       aesGcmKeyId = WH_TEST_AESGCM_KEYID;
    uint8_t       aesGcmWrappedKey[WH_TEST_AES_WRAPPED_KEYSIZE];
    const uint8_t ciphertext[] = {
        0x21, 0x20, 0x7f, 0x4a, 0x8f, 0x8c, 0xf3, 0x2c, 0x7c, 0xa7, 0x64, 0xa7,
        0x41, 0xf2, 0xcf, 0x72, 0xfd, 0x78, 0x5c, 0xda, 0xb0, 0x49, 0xae, 0xcd};
    const uint8_t iv[]  = {0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
                           0xde, 0xca, 0xf8, 0x88, 0x54, 0x40, 0xcd, 0x32};
    const uint8_t aad[] = {0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe,
                           0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad,
                           0xbe, 0xef, 0xab, 0xad, 0xda, 0xd2};
    uint8_t       tag[] = {
        0xf9, 0x67, 0x96, 0xc7, 0xb1, 0x54, 0xd5, 0x80,
        0x15, 0xb1, 0xb2, 0xf0, 0xfc, 0x1f, 0x57, 0x54,
    };
    uint8_t       decrypted[sizeof(ciphertext)];
    const uint8_t expected[] = "hello, wolfSSL AES-GCM!";

    /* Load wrapped AES GCM key from flash into RAM */
    ret = flashCb->Read(flashCtx, WH_TEST_AESGCM_KEY_OFFSET,
                        sizeof(aesGcmWrappedKey), aesGcmWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to read the AES GCM key from NVM %d\n", ret);
        return ret;
    }

    /* Request the server to unwrap and cache the key for us */
    ret = wh_Client_KeyUnwrapAndCache(client, WC_CIPHER_AES_GCM, serverKekId,
                                      aesGcmWrappedKey,
                                      sizeof(aesGcmWrappedKey), &aesGcmKeyId);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_KeyUnwrapAndCache %d\n", ret);
        return ret;
    }

    /* Initialize AES context */
    ret = wc_AesInit(aes, NULL, WH_DEV_ID);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_AesInit %d\n", ret);
        return ret;
    }

    ret = wh_Client_AesSetKeyId(aes, aesGcmKeyId);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_AesSetKeyId %d\n", ret);
        return ret;
    }

    /* Request the server to decrypt some data using the
     * unwrapped and cached key via the key ID */
    ret = wc_AesGcmDecrypt(aes, decrypted,                 /* out */
                           ciphertext, sizeof(ciphertext), /* in, inLen */
                           iv, sizeof(iv),                 /* iv, ivLen */
                           tag, sizeof(tag),  /* authTag, authTagSz */
                           aad, sizeof(aad)); /* authIn (AAD), authInSz */
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_AesGcmDecrypt %d\n", ret);
        return ret;
    }

    /* Check if the decrypted data matches an expected value */
    if (memcmp(decrypted, expected, sizeof(decrypted)) != 0) {
        WH_ERROR_PRINT("Decrypted value does not match expected value\n");
        return -1;
    }

    wh_Client_KeyErase(client, aesGcmKeyId);
    wc_AesFree(aes);

    return WH_ERROR_OK;
}
#endif /* HAVE_AESGCM */

#ifndef NO_RSA

static int _Rsa_WriteWrappedKeyToNvm(whClientContext* client, void* flashCtx,
                                     whFlashCb* flashCb)
{
    int     ret;
    whKeyId rsaKeyId                    = WH_TEST_RSA_KEYID;
    uint8_t rsaKey[WH_TEST_RSA_KEYSIZE] = {
        0x30, 0x82, 0x06, 0xe2, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x81, 0x00,
        0xb7, 0x9a, 0xcf, 0x47, 0x08, 0xbd, 0x33, 0x75, 0xdf, 0xa3, 0x39, 0xe8,
        0x66, 0x0a, 0xce, 0x9d, 0x59, 0xd7, 0xe5, 0xdc, 0x5a, 0x0e, 0xc5, 0xed,
        0xd3, 0x37, 0x3d, 0x00, 0x70, 0xba, 0x82, 0x02, 0x2a, 0x8b, 0x07, 0xbe,
        0x9e, 0x64, 0x60, 0x89, 0xdb, 0x6b, 0xa8, 0x02, 0x34, 0xdd, 0x73, 0x33,
        0x88, 0xd7, 0x40, 0xf1, 0xdf, 0xd8, 0x7a, 0x3a, 0x73, 0xb7, 0x7a, 0xbe,
        0xb2, 0x1f, 0xe2, 0x82, 0x0b, 0xb3, 0x43, 0x2d, 0xd0, 0x70, 0xe4, 0xa8,
        0xc6, 0xa1, 0xf8, 0xcd, 0x8d, 0x46, 0x8b, 0xda, 0xe1, 0x55, 0xb0, 0xf3,
        0xab, 0x45, 0x76, 0x37, 0x34, 0x82, 0x1e, 0x7c, 0x7e, 0x8d, 0x98, 0xfa,
        0x1a, 0x02, 0xd7, 0x0d, 0x09, 0x2f, 0x56, 0xf5, 0xeb, 0x2a, 0x7d, 0xaa,
        0x8b, 0x7d, 0xef, 0x17, 0x87, 0x59, 0xda, 0x46, 0xba, 0x19, 0xdc, 0xf3,
        0x25, 0x1c, 0xc0, 0x66, 0x8d, 0xee, 0x00, 0xc2, 0x23, 0xe6, 0xeb, 0x6d,
        0xb0, 0xf0, 0x04, 0xcb, 0xd0, 0xa6, 0xa0, 0x9b, 0x55, 0x00, 0xfd, 0xff,
        0xa0, 0xd9, 0x93, 0x38, 0xb1, 0x6c, 0xd4, 0x6e, 0xaf, 0x48, 0xbc, 0x63,
        0x9f, 0x4f, 0xa0, 0x82, 0x94, 0x34, 0x4b, 0xc0, 0xdc, 0x8b, 0x70, 0xd8,
        0x7a, 0x83, 0x53, 0xe2, 0x0d, 0xcc, 0x80, 0x72, 0x7d, 0x3b, 0x19, 0xa9,
        0x05, 0x83, 0x0a, 0x93, 0x5f, 0x81, 0xc9, 0x9c, 0x9f, 0x82, 0x37, 0x74,
        0xdc, 0x36, 0x39, 0x8c, 0x7c, 0x29, 0xeb, 0x9b, 0xc2, 0xa7, 0x94, 0x40,
        0xad, 0x38, 0x46, 0x11, 0x3d, 0x7f, 0xc8, 0x36, 0xbc, 0x09, 0xf0, 0x51,
        0x3e, 0xcc, 0x49, 0xfc, 0x3b, 0xcf, 0x50, 0xe5, 0xa3, 0x2a, 0x9c, 0x6b,
        0x2f, 0x54, 0xa5, 0xb5, 0x9e, 0xbc, 0xfc, 0x75, 0x3b, 0x56, 0x0a, 0xd7,
        0x16, 0x0f, 0x6a, 0xce, 0xc3, 0xeb, 0xfd, 0x01, 0x13, 0x16, 0xbe, 0x40,
        0x95, 0x92, 0x96, 0x76, 0x6f, 0x42, 0xf0, 0x25, 0xfa, 0x32, 0x3e, 0x2e,
        0xca, 0x37, 0xac, 0xe4, 0x70, 0xef, 0xc1, 0xa1, 0xbd, 0x77, 0x8a, 0x57,
        0x41, 0x88, 0xf4, 0x1b, 0x56, 0x4b, 0x2b, 0xed, 0xc1, 0x28, 0x35, 0x3b,
        0xa1, 0x9a, 0xa4, 0xce, 0xe7, 0x17, 0x05, 0x18, 0x2a, 0xba, 0x21, 0xa3,
        0x6a, 0x73, 0xa6, 0xbf, 0x81, 0xc3, 0x3d, 0x9c, 0x33, 0xf2, 0xe0, 0xa3,
        0xd0, 0x5a, 0x29, 0x63, 0xb4, 0xd3, 0x52, 0x3f, 0xc1, 0x0a, 0xcf, 0x79,
        0xad, 0x75, 0x63, 0x8c, 0xd5, 0xea, 0xed, 0xb3, 0xb4, 0xfd, 0xb3, 0xee,
        0x66, 0xdf, 0x79, 0x72, 0xa1, 0x7f, 0x47, 0xe0, 0xec, 0xfd, 0xe2, 0x95,
        0xfb, 0x98, 0x13, 0x0d, 0x85, 0xec, 0x8b, 0xdc, 0x0e, 0x0f, 0x19, 0x95,
        0xee, 0xea, 0x1a, 0xe5, 0x0d, 0x9a, 0x5c, 0xc6, 0x83, 0xe8, 0x1b, 0xde,
        0x33, 0xef, 0x64, 0x96, 0x64, 0xe3, 0x26, 0xfd, 0x62, 0x73, 0xab, 0x63,
        0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01, 0x80, 0x04, 0x67, 0x31,
        0x06, 0x04, 0xbe, 0xa2, 0x27, 0xa1, 0xd7, 0xaf, 0x41, 0x7f, 0x2e, 0x4e,
        0x80, 0x2a, 0xdc, 0x68, 0xf0, 0x72, 0x34, 0x72, 0x7e, 0x09, 0x42, 0x5a,
        0x33, 0x28, 0x2b, 0x96, 0x31, 0xe9, 0x1a, 0x9b, 0xc7, 0xf0, 0x27, 0xd0,
        0xc2, 0x32, 0xec, 0x8f, 0xad, 0xe5, 0xdd, 0xfd, 0xaf, 0x99, 0xb3, 0x82,
        0x7a, 0x35, 0x22, 0x62, 0xe4, 0x03, 0x4c, 0x68, 0xce, 0xd3, 0xef, 0x67,
        0x26, 0x33, 0xe8, 0xf6, 0x4e, 0x78, 0xa0, 0xe1, 0xca, 0xee, 0x60, 0x8a,
        0x05, 0x46, 0x98, 0x64, 0xd8, 0x38, 0x99, 0x2e, 0x7c, 0xd9, 0x79, 0xa3,
        0xf9, 0x1f, 0x9d, 0x93, 0x3a, 0x41, 0xc0, 0x06, 0xe5, 0x7b, 0x39, 0x8a,
        0xe0, 0xb9, 0x7c, 0xaa, 0x25, 0x8c, 0x4b, 0x36, 0x3c, 0xf5, 0xca, 0xc2,
        0x5b, 0x6f, 0xc2, 0x86, 0xdf, 0xe0, 0x01, 0xfe, 0x1b, 0x7d, 0x4e, 0x05,
        0x8b, 0x30, 0x12, 0x2a, 0x1b, 0x28, 0x73, 0x41, 0x92, 0xc8, 0x30, 0x7e,
        0xb2, 0x48, 0x97, 0x06, 0x63, 0xa8, 0x93, 0xdf, 0xd8, 0xd6, 0x89, 0xab,
        0xe4, 0x80, 0x7f, 0x6f, 0x4f, 0x6c, 0x38, 0x09, 0x54, 0x8b, 0x9d, 0xd9,
        0x92, 0x92, 0xc2, 0xa2, 0x4d, 0x1b, 0x67, 0x8e, 0x00, 0x3d, 0xb2, 0x92,
        0x90, 0xbe, 0xeb, 0x4d, 0x95, 0x46, 0xa2, 0xe3, 0xdd, 0xa5, 0x7a, 0x86,
        0xb1, 0x66, 0xbe, 0x9d, 0x10, 0x25, 0x7f, 0x20, 0xf1, 0xf6, 0x68, 0x9d,
        0xa4, 0xf7, 0xa6, 0xe1, 0x4a, 0x96, 0x31, 0xb0, 0x4c, 0x38, 0xdf, 0xe3,
        0xd6, 0xba, 0x2d, 0xc0, 0xf6, 0x13, 0xf2, 0xe5, 0x05, 0xbc, 0xe2, 0x78,
        0x28, 0x25, 0xe0, 0x47, 0x8f, 0xd5, 0x90, 0x8d, 0x43, 0xb0, 0x55, 0x97,
        0x50, 0x8d, 0x2f, 0x0c, 0xcf, 0x73, 0x63, 0x3d, 0x6a, 0x48, 0x51, 0x0d,
        0xd0, 0x39, 0x59, 0x54, 0xc7, 0xf0, 0x53, 0xab, 0x95, 0xcd, 0xe7, 0x43,
        0x17, 0xa6, 0x94, 0x68, 0xcc, 0xda, 0x5d, 0x3e, 0xfa, 0xe6, 0xca, 0x00,
        0x13, 0xa8, 0x44, 0xb2, 0x5b, 0x40, 0x92, 0x27, 0xd8, 0xf6, 0x26, 0xba,
        0xb8, 0x38, 0x0a, 0x50, 0xb7, 0xa9, 0xe0, 0x7c, 0x34, 0xd6, 0x51, 0xc0,
        0xf0, 0x45, 0xed, 0xa9, 0x99, 0x65, 0x03, 0x7e, 0x90, 0x32, 0x96, 0x39,
        0x1b, 0xde, 0x7a, 0x38, 0x88, 0x9f, 0xb6, 0x47, 0xfe, 0x05, 0xcd, 0xfe,
        0xe9, 0x22, 0x1b, 0x95, 0x9d, 0x8b, 0x56, 0x9a, 0x32, 0x9b, 0xd1, 0xaa,
        0x41, 0x11, 0x8f, 0xac, 0x42, 0x6c, 0xe7, 0x6d, 0xe0, 0x3a, 0x7f, 0x95,
        0xd0, 0x05, 0x02, 0xae, 0x02, 0xa2, 0xe4, 0xc2, 0xc5, 0xb6, 0xc6, 0x8c,
        0x2d, 0x79, 0x97, 0x63, 0xc3, 0x05, 0x31, 0x63, 0x51, 0xee, 0x42, 0xd4,
        0x55, 0xad, 0x4d, 0x93, 0x2f, 0x78, 0xd8, 0x75, 0xd8, 0xba, 0x08, 0xc4,
        0x14, 0xad, 0x53, 0x45, 0x6e, 0x1e, 0x63, 0x53, 0x41, 0x02, 0x81, 0xc1,
        0x00, 0xe7, 0xdf, 0x17, 0xd1, 0x23, 0x98, 0x6b, 0xd1, 0xea, 0x60, 0x88,
        0x83, 0x2a, 0x23, 0x46, 0x01, 0xd9, 0x8f, 0x43, 0x4d, 0xd0, 0x91, 0x7c,
        0xbf, 0x28, 0x52, 0x28, 0x1c, 0x39, 0x7d, 0x43, 0x09, 0x21, 0xff, 0xa2,
        0x6e, 0xba, 0xa4, 0x30, 0x4a, 0x29, 0x28, 0xa3, 0xfb, 0xf6, 0x83, 0x3c,
        0xb7, 0x5b, 0x37, 0xfc, 0xdc, 0x38, 0x87, 0xbe, 0x19, 0x96, 0xc6, 0xcb,
        0x79, 0xd0, 0x42, 0xa9, 0x62, 0x5f, 0xfc, 0xa3, 0x48, 0xde, 0x12, 0x1f,
        0xf3, 0x92, 0x54, 0x34, 0xda, 0x03, 0x30, 0xf1, 0xcd, 0xf5, 0x2b, 0x69,
        0x6b, 0xd4, 0xf3, 0x2b, 0x30, 0x84, 0xef, 0xa1, 0x2a, 0xfa, 0x1d, 0x7b,
        0xa8, 0xf4, 0x8f, 0xb5, 0x96, 0xcb, 0x5c, 0x6f, 0x9a, 0xb7, 0x8b, 0xf9,
        0x18, 0x30, 0x14, 0x76, 0xc4, 0xec, 0x93, 0x85, 0x07, 0x2c, 0x6f, 0x0f,
        0x56, 0xbb, 0x26, 0xb8, 0x6a, 0xc4, 0x0b, 0x5a, 0xca, 0x50, 0xfd, 0xba,
        0x0a, 0x8e, 0xe0, 0x1c, 0x27, 0x59, 0x2c, 0xec, 0x9e, 0xf2, 0xf6, 0xcd,
        0x47, 0x8a, 0xcf, 0x6b, 0x14, 0x35, 0xe3, 0x87, 0xc0, 0xc0, 0xea, 0xe2,
        0xe0, 0x52, 0x58, 0x8a, 0xee, 0xf1, 0x93, 0x69, 0x90, 0xd1, 0x00, 0x9b,
        0xa7, 0x71, 0xaa, 0x70, 0x3d, 0xdb, 0xf1, 0x08, 0x5d, 0x97, 0x7a, 0x46,
        0xbf, 0x53, 0xd9, 0xbe, 0xa9, 0x65, 0x9c, 0xcf, 0x06, 0x68, 0xcd, 0x37,
        0x83, 0x02, 0x81, 0xc1, 0x00, 0xca, 0xb5, 0xeb, 0xfe, 0x5a, 0x0f, 0x25,
        0x87, 0x5c, 0xfb, 0xc4, 0x77, 0x39, 0xfb, 0xa3, 0x0f, 0xa8, 0xb4, 0xfd,
        0x41, 0x29, 0xdc, 0x16, 0x4c, 0x39, 0xbc, 0x25, 0xe6, 0xa0, 0xae, 0xe1,
        0x97, 0xb1, 0x43, 0xb5, 0x5f, 0x64, 0x5a, 0xf2, 0x7d, 0xe4, 0x83, 0xad,
        0x94, 0xa7, 0xcc, 0x8a, 0x01, 0xe9, 0x51, 0x3e, 0xef, 0xe9, 0x72, 0xc6,
        0x8b, 0x01, 0x04, 0xa7, 0xe1, 0x83, 0x47, 0x67, 0x09, 0xe7, 0xd8, 0xc7,
        0xb0, 0xab, 0x80, 0x7d, 0x54, 0xef, 0xf6, 0xc3, 0xf2, 0x43, 0xfd, 0x41,
        0xf6, 0x98, 0xe2, 0xc8, 0x66, 0x66, 0xef, 0x3a, 0xba, 0x43, 0x58, 0x0d,
        0x65, 0xc8, 0x44, 0x35, 0xa3, 0x6b, 0xf4, 0xa1, 0xae, 0x8c, 0x05, 0x5e,
        0xdc, 0x33, 0xff, 0xce, 0x23, 0x8e, 0x06, 0xa0, 0xbb, 0xf0, 0x8c, 0xc7,
        0xcf, 0x5b, 0x32, 0xdb, 0x9f, 0x35, 0xaa, 0x8e, 0x61, 0x13, 0x32, 0x1a,
        0x91, 0x06, 0xe9, 0x98, 0xa1, 0x56, 0xe5, 0x83, 0xc2, 0xe7, 0x87, 0x24,
        0x31, 0x9d, 0xba, 0x37, 0xe0, 0xd6, 0xfd, 0x46, 0x15, 0xdb, 0x65, 0x65,
        0xe3, 0xf9, 0x91, 0xd4, 0xe6, 0xfa, 0xeb, 0x53, 0xfe, 0x26, 0x18, 0xf4,
        0x4b, 0x31, 0x0b, 0x95, 0xc4, 0xf7, 0xb8, 0xf9, 0x06, 0xcf, 0xd5, 0xe1,
        0x67, 0xe3, 0x0c, 0x0b, 0x1d, 0x0c, 0x78, 0xc5, 0x8f, 0xd0, 0xc0, 0xa7,
        0xc4, 0xd6, 0x1f, 0x96, 0xa1, 0x02, 0x81, 0xbf, 0x39, 0x0f, 0xad, 0xcc,
        0xc9, 0xf5, 0xb8, 0x92, 0xf0, 0x1a, 0xd1, 0x7d, 0x75, 0xe1, 0x38, 0x59,
        0x3c, 0x31, 0x05, 0x5f, 0x20, 0xf4, 0xac, 0xbe, 0x5e, 0x2d, 0xd9, 0xb1,
        0x18, 0x74, 0xbb, 0x0a, 0x84, 0x53, 0x64, 0xa5, 0xdb, 0x48, 0x8c, 0x99,
        0xb3, 0x87, 0x4c, 0xd3, 0xb4, 0xd6, 0x97, 0x1a, 0x88, 0x58, 0x3e, 0xe1,
        0xf3, 0x07, 0x74, 0xc0, 0xd7, 0x5a, 0x14, 0xb8, 0xe5, 0x87, 0x82, 0x27,
        0xb3, 0x77, 0x78, 0xb7, 0x75, 0xee, 0xff, 0xed, 0xf1, 0x14, 0xc7, 0xec,
        0xde, 0xdc, 0x2c, 0xa5, 0x82, 0xb0, 0x2c, 0x41, 0x5d, 0x26, 0x7a, 0x7a,
        0x76, 0x3c, 0x82, 0x6d, 0x11, 0x20, 0x30, 0x4e, 0x63, 0xe0, 0xf9, 0xcf,
        0x22, 0x3c, 0x9d, 0x3a, 0x75, 0xf0, 0xfc, 0x5b, 0xf7, 0x79, 0x11, 0xc1,
        0x64, 0x76, 0xe9, 0x45, 0xda, 0xa9, 0x7a, 0x1c, 0xdd, 0xf1, 0xa9, 0x70,
        0x9c, 0xce, 0x2e, 0x89, 0x9b, 0x64, 0xd5, 0x63, 0xc3, 0xc5, 0x63, 0x28,
        0x4b, 0xc9, 0xc2, 0x71, 0x5b, 0x59, 0x61, 0x2b, 0x39, 0xfd, 0xd1, 0x5c,
        0x27, 0xe6, 0xd6, 0x81, 0x98, 0xf8, 0x34, 0xdc, 0xff, 0x66, 0xca, 0xca,
        0x02, 0xa9, 0x44, 0x51, 0x5f, 0x1d, 0xc7, 0x30, 0x6d, 0xc8, 0x83, 0xd6,
        0xb5, 0x49, 0x9b, 0xc5, 0x6c, 0x81, 0xaa, 0xe7, 0x6a, 0xbb, 0x2b, 0x30,
        0x84, 0xd1, 0x12, 0x21, 0x81, 0xa8, 0xff, 0x02, 0x81, 0xc1, 0x00, 0xc2,
        0x0d, 0x99, 0x97, 0x6a, 0x7b, 0x69, 0x7f, 0xc6, 0x01, 0xb6, 0xb8, 0x34,
        0x27, 0xb2, 0x97, 0xc0, 0xf7, 0x52, 0x21, 0xd9, 0x82, 0xb9, 0x4d, 0xcb,
        0x4f, 0x54, 0x31, 0x0d, 0xcd, 0x9c, 0x64, 0x6c, 0xeb, 0xd6, 0x6b, 0x35,
        0x54, 0xe3, 0x22, 0xa5, 0x69, 0x70, 0xf8, 0x08, 0x12, 0x84, 0x63, 0x04,
        0x0a, 0x24, 0xe7, 0xe2, 0x61, 0x5f, 0xb3, 0x9e, 0x0b, 0xe8, 0xf2, 0xb7,
        0x8b, 0xd9, 0x15, 0xe0, 0x7e, 0xe3, 0xdb, 0x3a, 0xb2, 0xcc, 0x48, 0x4d,
        0x57, 0xbb, 0x88, 0xe6, 0x91, 0x41, 0x5e, 0x62, 0x49, 0x67, 0x72, 0xb0,
        0x43, 0x7f, 0xc2, 0xe3, 0xc9, 0x1d, 0x3a, 0x3c, 0x97, 0x1f, 0x8a, 0x0c,
        0x44, 0xa9, 0xaa, 0xc0, 0x9c, 0x3b, 0x8d, 0x2d, 0xb2, 0x4a, 0x92, 0x3a,
        0xda, 0x19, 0x71, 0x10, 0xfc, 0x94, 0x22, 0xea, 0xb9, 0x2b, 0x09, 0xa4,
        0x84, 0x5b, 0xbc, 0x8e, 0x75, 0xbe, 0x7c, 0xeb, 0x53, 0x20, 0x2c, 0x03,
        0x55, 0xbf, 0xe7, 0x0b, 0x61, 0x91, 0xc2, 0x75, 0xad, 0xd8, 0xe4, 0x42,
        0xab, 0x3f, 0x36, 0x99, 0x4a, 0xde, 0x59, 0x79, 0x86, 0xa3, 0x7b, 0x62,
        0xe5, 0x79, 0x08, 0xa9, 0x4b, 0xe6, 0x41, 0x3c, 0xf8, 0x4c, 0x2d, 0xbc,
        0xbf, 0xb4, 0x95, 0x52, 0xcc, 0xfa, 0xf5, 0x4a, 0xa3, 0x32, 0xd8, 0x62,
        0x22, 0x13, 0x6e, 0x73, 0x76, 0x9a, 0xa4, 0x92, 0x1e, 0xb7, 0x41, 0x02,
        0x81, 0xc0, 0x1e, 0x48, 0x4f, 0x1c, 0x95, 0xc0, 0xfc, 0xad, 0x57, 0xba,
        0x4c, 0x51, 0xcd, 0x46, 0x1f, 0x56, 0x40, 0xa6, 0x5a, 0xfd, 0x90, 0xe7,
        0x5a, 0x11, 0xec, 0x46, 0x42, 0x09, 0x31, 0xb8, 0xf4, 0xbb, 0x6a, 0x25,
        0xde, 0xf9, 0xc4, 0xa7, 0xa9, 0x02, 0x10, 0x73, 0x4b, 0xae, 0x16, 0x69,
        0x5a, 0x36, 0x0f, 0xb3, 0xf0, 0x14, 0x6b, 0x3a, 0x2b, 0x8f, 0xf3, 0x7a,
        0x4e, 0x22, 0x13, 0x8e, 0x51, 0x62, 0x7d, 0x6e, 0x57, 0x59, 0x6b, 0xb8,
        0x6d, 0xd7, 0x95, 0x0d, 0xcc, 0xc2, 0x59, 0xb2, 0x03, 0x89, 0x62, 0x34,
        0xdc, 0xef, 0x3a, 0x72, 0x87, 0x31, 0xab, 0xaf, 0x63, 0xa3, 0x73, 0x0a,
        0x1c, 0x67, 0xe5, 0x1f, 0x9e, 0xd0, 0xc4, 0x59, 0xc6, 0xe2, 0x52, 0x85,
        0x29, 0xc4, 0x19, 0xad, 0xbf, 0x3e, 0x28, 0x87, 0xf1, 0xad, 0x50, 0x5a,
        0xfc, 0x46, 0x23, 0x0d, 0x45, 0x13, 0x57, 0xd7, 0x79, 0x35, 0x45, 0xfe,
        0x6f, 0x6f, 0x8e, 0xc7, 0x5d, 0x27, 0x8a, 0xd1, 0x09, 0x98, 0xe8, 0x30,
        0xa6, 0x16, 0x33, 0xf0, 0x97, 0xd8, 0xdb, 0x63, 0xaa, 0xbc, 0x20, 0xc1,
        0xf0, 0xad, 0x37, 0xa2, 0x49, 0xb8, 0xeb, 0x67, 0xc2, 0xc3, 0x7a, 0xa1,
        0xc0, 0x31, 0xd8, 0x59, 0xba, 0x98, 0x60, 0xe9, 0xe4, 0xbc, 0x82, 0xad,
        0xdc, 0xaf, 0x94, 0x1a, 0xce, 0xd8, 0xc6, 0xc8, 0xf5, 0x36, 0xa0, 0x55,
        0xf1, 0x41};
    uint8_t       rsaWrappedKey[WH_TEST_RSA_WRAPPED_KEYSIZE];
    whNvmMetadata rsaKeyMetadata = {
        .label  = "RSA 3072 Key",
        .access = WH_NVM_ACCESS_ANY,
        .flags  = WH_NVM_FLAGS_NONE,
        .id     = WH_MAKE_KEYID(WH_KEYTYPE_CRYPTO, 0, rsaKeyId),
        .len    = sizeof(rsaKey)};

    /* Request the server to wrap the RSA key using the server KEK */
    ret = wh_Client_KeyWrap(client, WC_CIPHER_AES_GCM, WH_TEST_KEKID, rsaKey,
                            sizeof(rsaKey), &rsaKeyMetadata, rsaWrappedKey,
                            sizeof(rsaWrappedKey));
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_KeyWrap %d\n", ret);
        return ret;
    }

    /* Write the wrapped RSA key to a specified location in flash */
    ret = flashCb->Program(flashCtx, WH_TEST_RSA_KEY_OFFSET,
                           sizeof(rsaWrappedKey), rsaWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to write RSA key to NVM %d\n", ret);
        return ret;
    }

    ret = flashCb->Verify(flashCtx, WH_TEST_RSA_KEY_OFFSET,
                          sizeof(rsaWrappedKey), rsaWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to verify the RSA key written to flash %d\n",
                       ret);
        return ret;
    }

    return ret;
}

static int _Rsa_UseWrappedKeyFromNvm(whClientContext* client, void* flashCtx,
                                     whFlashCb* flashCb)
{
    int     ret;
    whKeyId serverKekId = WH_TEST_KEKID;

    RsaKey  rsa[1];
    whKeyId rsaKeyId = WH_TEST_RSA_KEYID;
    uint8_t rsaWrappedKey[WH_TEST_RSA_WRAPPED_KEYSIZE];

    const uint8_t ciphertext[] = {
        0x93, 0x70, 0xdc, 0x6f, 0x6a, 0xbd, 0xe6, 0x64, 0x6b, 0xeb, 0xe4, 0x4d,
        0xf3, 0xf3, 0x55, 0x0d, 0x30, 0x2d, 0x60, 0xa8, 0x9c, 0x9e, 0x4a, 0x90,
        0x76, 0x77, 0x59, 0x47, 0x30, 0xa1, 0x53, 0xb1, 0xb9, 0x5d, 0x05, 0xdb,
        0x19, 0xaa, 0x1b, 0xca, 0xf2, 0xf6, 0xf2, 0x02, 0xf3, 0x6e, 0xbf, 0xd0,
        0x92, 0xa8, 0xba, 0x7d, 0xa3, 0xe0, 0x11, 0xbc, 0xe2, 0xae, 0xf1, 0x64,
        0x17, 0x6d, 0xa5, 0x3d, 0x52, 0xa3, 0x39, 0x08, 0xac, 0x69, 0xff, 0x55,
        0x10, 0x4c, 0x64, 0x18, 0x9f, 0x36, 0x5b, 0xe0, 0x40, 0xdb, 0xe9, 0x42,
        0x89, 0x8b, 0xe7, 0xfc, 0xb5, 0xe9, 0x1c, 0x13, 0x14, 0xc0, 0xb7, 0x48,
        0x9b, 0x06, 0x31, 0x83, 0x33, 0x6d, 0x95, 0x4a, 0x89, 0xbd, 0xe5, 0x54,
        0xa2, 0x98, 0xf0, 0x00, 0x07, 0xef, 0xc0, 0x88, 0x95, 0xf4, 0xe8, 0xd8,
        0x1c, 0x9b, 0xde, 0x68, 0xe8, 0x2d, 0xe7, 0xc4, 0x19, 0xc1, 0x9b, 0x90,
        0x74, 0x21, 0xfe, 0x96, 0xec, 0x4a, 0x1f, 0x4d, 0x10, 0x20, 0xff, 0xec,
        0x4a, 0x2d, 0x38, 0x91, 0x92, 0xac, 0x01, 0x97, 0x6a, 0x14, 0xd5, 0x14,
        0xaa, 0xd5, 0x94, 0x20, 0x61, 0xb0, 0x96, 0x5c, 0xfb, 0xc5, 0x41, 0xf9,
        0xa3, 0x96, 0xeb, 0x18, 0x99, 0x13, 0xb2, 0x17, 0x87, 0xfc, 0xd5, 0xf0,
        0x8d, 0x91, 0xe3, 0xe8, 0x5a, 0xf5, 0x30, 0xa1, 0x12, 0x64, 0xbc, 0xc3,
        0x96, 0x47, 0x66, 0x5d, 0x68, 0xe3, 0x2a, 0x44, 0x1d, 0x9d, 0x4f, 0x76,
        0xfe, 0x3d, 0x7a, 0xd8, 0x5e, 0x87, 0x3e, 0x61, 0xce, 0x24, 0x1c, 0x8c,
        0x32, 0x24, 0xd0, 0x47, 0xcf, 0xee, 0x14, 0x68, 0x01, 0x23, 0xa0, 0x45,
        0xe1, 0x0b, 0x42, 0xc2, 0x12, 0x5f, 0x71, 0x80, 0x95, 0xae, 0xd1, 0xae,
        0xb0, 0x35, 0xb3, 0x57, 0x8d, 0xcf, 0x9f, 0xbb, 0xa4, 0x0e, 0xfb, 0x31,
        0x02, 0x16, 0x51, 0xec, 0x84, 0xc0, 0x51, 0x64, 0x58, 0x4e, 0xf7, 0x69,
        0x64, 0xf6, 0x52, 0xa4, 0x0e, 0x5d, 0x09, 0x80, 0x2e, 0x8a, 0x49, 0xfa,
        0xdf, 0x58, 0x70, 0xd2, 0x7f, 0xf5, 0xb2, 0x99, 0xfb, 0x59, 0x70, 0x37,
        0x59, 0x95, 0x75, 0x98, 0x1f, 0x21, 0x9d, 0x3a, 0x39, 0xf7, 0x99, 0x0b,
        0x7d, 0x2e, 0xbb, 0x43, 0x95, 0xd9, 0xe2, 0x54, 0xbb, 0x81, 0xdc, 0xce,
        0x6b, 0x69, 0xcb, 0x8a, 0x88, 0x98, 0x6b, 0x51, 0x00, 0x8c, 0x26, 0xa0,
        0x7a, 0x50, 0xbc, 0xa7, 0x77, 0x4b, 0xd5, 0x66, 0x41, 0xd1, 0xc4, 0xd1,
        0xbc, 0x8c, 0x02, 0xb8, 0x7c, 0x76, 0x0e, 0xa5, 0x8a, 0xd7, 0xdd, 0x89,
        0x16, 0xe0, 0xd4, 0x7b, 0x0d, 0x2b, 0xfb, 0x86, 0xe9, 0xbf, 0x18, 0xfc,
        0xf9, 0x98, 0x49, 0x0d, 0x3a, 0x79, 0xee, 0xf1, 0x02, 0x4c, 0xc5, 0x41,
        0xd3, 0x28, 0xe8, 0xe9, 0x31, 0x6a, 0x1a, 0xc7, 0xca, 0x67, 0x18, 0x2c,
    };

    uint8_t       decrypted[sizeof(ciphertext)];
    const uint8_t expected[] = "Hello with RSA-3072!";

    /* Load wrapped RSA key from flash into RAM */
    ret = flashCb->Read(flashCtx, WH_TEST_RSA_KEY_OFFSET, sizeof(rsaWrappedKey),
                        rsaWrappedKey);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to read the RSA wrapped key from NVM %d\n", ret);
        return ret;
    }

    /* Request the server to unwrap and cache the key for us */
    ret = wh_Client_KeyUnwrapAndCache(client, WC_CIPHER_AES_GCM, serverKekId,
                                      rsaWrappedKey, sizeof(rsaWrappedKey),
                                      &rsaKeyId);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_KeyUnwrapAndCache %d\n", ret);
        return ret;
    }

    /* Initialize the rsa key */
    ret = wc_InitRsaKey_ex(rsa, NULL, WH_DEV_ID);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wc_InitRsaKey_ex %d\n", ret);
        return ret;
    }

    /* Set the assigned keyId */
    ret = wh_Client_RsaSetKeyId(rsa, rsaKeyId);
    if (ret != 0) {
        WH_ERROR_PRINT("Failed to wh_Client_SetKeyIdRsa %d\n", ret);
        return ret;
    }

    /* Request the server to decrypt some data using the
     * unwrapped and cached key via the key ID */
    ret = wc_RsaPrivateDecrypt_ex(ciphertext, sizeof(ciphertext), decrypted,
                                  sizeof(decrypted), rsa, WC_RSA_OAEP_PAD,
                                  WC_HASH_TYPE_SHA256, WC_MGF1SHA256, NULL, 0);
    if (ret < 0) {
        WH_ERROR_PRINT("Failed to wc_RsaPrivateDecrypt %d\n", ret);
        return ret;
    }

    /* Check if the decrypted data matches an expected value */
    if (memcmp(decrypted, expected, sizeof(expected)) != 0) {
        WH_ERROR_PRINT("Decrypted value does not match expected value\n");
        return -1;
    }

    wh_Client_KeyErase(client, rsaKeyId);
    wc_FreeRsaKey(rsa);
    return WH_ERROR_OK;
}
#endif /* !NO_RSA */

int whTest_Client_WriteWrappedKeysToNvm(whClientContext* client, void* flashCtx,
                                        whFlashCb* flashCb)
{
    int ret = WH_ERROR_OK;

    ret = _InitServerKek(client);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to _InitServerKek %d\n", ret);
        return ret;
    }

#ifdef HAVE_AESGCM
    ret = _AesGcm_WriteWrappedKeyToNvm(client, flashCtx, flashCb);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to _AesGcm_WriteWrappedKeyToNvm %d\n", ret);
        return ret;
    }
#endif /* HAVE_AESGCM */

#ifndef NO_RSA
    ret = _Rsa_WriteWrappedKeyToNvm(client, flashCtx, flashCb);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to _Rsa_WriteWrappedKeyToNvm %d\n", ret);
        return ret;
    }
#endif /* !NO_RSA */

    _CleanupServerKek(client);

    return WH_ERROR_OK;
}

int whTest_Client_UseWrappedKeysFromNvm(whClientContext* client, void* flashCtx,
                                        whFlashCb* flashCb)
{
    int ret = WH_ERROR_OK;

    _InitServerKek(client);

#ifdef HAVE_AESGCM
    ret = _AesGcm_UseWrappedKeyFromNvm(client, flashCtx, flashCb);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to _AesGcm_UseWrappedKeyToNvm %d\n", ret);
        return ret;
    }
#endif /* HAVE_AESGCM */

#ifndef NO_RSA
    ret = _Rsa_UseWrappedKeyFromNvm(client, flashCtx, flashCb);
    if (ret != WH_ERROR_OK) {
        WH_ERROR_PRINT("Failed to _Rsa_UseWrappedKeyFromNvm %d\n", ret);
        return ret;
    }
#endif /* !NO_RSA */

    _CleanupServerKek(client);
    return ret;
}

#endif /* WOLFHSM_CFG_ENABLE_CLIENT */
#endif /* WOLFHSM_CFG_KEYWRAP */
